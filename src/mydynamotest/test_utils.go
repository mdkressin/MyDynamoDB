package mydynamotest

import (
	"log"
	"mydynamo"
	"os"
	"os/exec"
	"strconv"
	"github.com/go-ini/ini"
)

//Creats a command that will start Dynamo nodes based on the config file specified
// by config_path
func InitDynamoServer(config_path string) *exec.Cmd {
	serverCmd := exec.Command("DynamoCoordinator", config_path)
	serverCmd.Stderr = os.Stderr
	serverCmd.Stdout = os.Stdout
	return serverCmd
}

//Executes the command generated by InitDynamoServer
func StartDynamoServer(server *exec.Cmd, ready chan bool) {
	err := server.Start()
	if err != nil {
		log.Println(err)
	}

	ready <- true
}

//Kills the Dynamo servers generated by InitDynamoServer
func KillDynamoServer(server *exec.Cmd) {
	_ = server.Process.Kill()
	exec.Command("pkill SurfstoreServerExec*")
}

//Creates a client that connects to the given port
//A client instance returned by this function is ready to use
func MakeConnectedClient(port int) *mydynamo.RPCClient {
	clientInstance := mydynamo.NewDynamoRPCClient("localhost:" + strconv.Itoa(port))
	clientInstance.RpcConnect()
	return clientInstance
}

//Creates a PutArgs with the associated key and value, but a Context corresponding
//to a new VectorClock
func PutFreshContext(key string, value []byte) mydynamo.PutArgs {
	return mydynamo.NewPutArgs(key, mydynamo.NewContext(mydynamo.NewVectorClock()), value)
}

//Tests if the contents of two byte arrays are equal
func valuesEqual(v1 []byte, v2 []byte) bool {
	if len(v1) != len(v2) {
		return false
	}
	for idx, b := range v1 {
		if b != v2[idx] {
			return false
		}
	}
	return true
}

func setClusterSize(configFilePath string) {
	configContent, err := ini.Load(configFilePath)
	if err != nil {
		log.Println(err)
		log.Println("Failed to load config file:", configFilePath)
		log.Println(mydynamo.USAGE_STRING)
		os.Exit(mydynamo.EX_CONFIG)
	}

	// Load the detailed configuration from section "mydynamo"
	dynamoConfigs := configContent.Section(mydynamo.MYDYNAMO)

	cluster_size, err := dynamoConfigs.Key(mydynamo.CLUSTER_SIZE).Int()
	if err != nil {
		log.Println(err)
		log.Println("Failed to load config file, field is wrong type:", configFilePath)
		log.Println(mydynamo.USAGE_STRING)
		os.Exit(mydynamo.EX_CONFIG)
	}

	// set the cluster size
	mydynamo.SetClusterSize(cluster_size)
}

func makeClocksList(numClocks int) []mydynamo.VectorClock {
	var clocks []mydynamo.VectorClock

	for i := 0; i < numClocks; i++ {
		clocks	= append(clocks, mydynamo.NewVectorClock())
	}
	return clocks
}
func incElementVersion(s *mydynamo.VectorClock, id string, version int) {
	for i := 0; i < version; i++ {
		s.Increment(id)
	}
}
func resetElement(s *mydynamo.VectorClock, id string) {
	//element	:= mydynamo.NewElement(id)
	//s.Elements[s.GetNodeAtoi(id)]	= element
	delete(s.Elements, id)
}
func setElementVersion(s *mydynamo.VectorClock, id string, version int) {
	resetElement(s, id)
	incElementVersion(s, id, version)
}

func checkVersionFromResult(result mydynamo.DynamoResult, id string, version int) bool {
	if result.EntryList == nil || len(result.EntryList) == 0 {
		return false
	}
	return result.EntryList[0].Context.Clock.VersionIs(id, version)
}
